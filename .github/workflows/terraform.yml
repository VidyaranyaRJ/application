name: Deploy Node.js Application

on:
  push:
    branches: [nodejs]
  workflow_dispatch:

env:
  S3_BUCKET: vj-test-benvolate
  ZIP_NAME: nodejs-app.zip
  ZIP_S3_KEY: artifacts/nodejs-app.zip
  EFS_PATH: /mnt/efs/code
  AWS_REGION: us-east-2
  TF_STATE_BUCKET: vj-test-benvolate
  TF_STATE_KEY: "EC2/terraform.tfstate"

jobs:
  deploy-nodejs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Node.js App Repo
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Zip Node.js App
        run: |
          zip -r ${{ env.ZIP_NAME }} .
          echo "Zipped application size: $(ls -lh ${{ env.ZIP_NAME }} | awk '{print $5}')"

      - name: Upload ZIP to S3
        run: |
          aws s3 cp ${{ env.ZIP_NAME }} s3://${{ env.S3_BUCKET }}/${{ env.ZIP_S3_KEY }}

      - name: Read EC2 Instance ID from Terraform state in S3
        run: |
          aws s3 cp s3://${{ env.TF_STATE_BUCKET }}/${{ env.TF_STATE_KEY }} tfstate.json
          INSTANCE_ID=$(jq -r '.outputs.module_instance_id_for_ssm.value' tfstate.json)
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

      - name: Deploy and restart app via SSM (Zero Downtime)
        run: |
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "TIMESTAMP=$(date +%Y%m%d%H%M%S)",
              "mkdir -p ${{ env.EFS_PATH }}/backups",
              "if [ -d \"${{ env.EFS_PATH }}/nodejs-app\" ]; then cp -r ${{ env.EFS_PATH }}/nodejs-app ${{ env.EFS_PATH }}/backups/nodejs-app-$TIMESTAMP; fi",

              "aws s3 cp s3://${{ env.S3_BUCKET }}/${{ env.ZIP_S3_KEY }} /tmp/${{ env.ZIP_NAME }}",
              "unzip -o /tmp/${{ env.ZIP_NAME }} -d ${{ env.EFS_PATH }}/nodejs-app-temp",
              "cd ${{ env.EFS_PATH }}/nodejs-app-temp",
              "npm install",

              "nohup node index.js > ${{ env.EFS_PATH }}/logs/app-temp.log 2>&1 & echo $! > app-temp.pid",
              "sleep 5",

              "if ps -p $(cat app-temp.pid) > /dev/null; then echo 'New app started'; else echo 'New app failed'; exit 1; fi",

              "cp -r ${{ env.EFS_PATH }}/nodejs-app-temp/* ${{ env.EFS_PATH }}/nodejs-app/",
              "kill $(cat ${{ env.EFS_PATH }}/nodejs-app/app.pid) || echo 'No existing app to stop'",
              "mv ${{ env.EFS_PATH }}/nodejs-app-temp/app-temp.pid ${{ env.EFS_PATH }}/nodejs-app/app.pid",

              "sudo nginx -t && sudo systemctl reload nginx",
              "tail -n 20 ${{ env.EFS_PATH }}/logs/app-temp.log"
            ]' \
            --comment "Zero downtime Node.js app deploy and Nginx reload" \
            --region ${{ env.AWS_REGION }} \
            --query "Command.CommandId" \
            --output text)

          echo "SSM command sent: $CMD_ID"

          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} \
              --query "Status" \
              --output text)

            echo "Command status: $STATUS"
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment successful."
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "❌ Deployment failed."
              exit 1
            fi
            sleep 5
          done
