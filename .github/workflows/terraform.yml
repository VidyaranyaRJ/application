name: Deploy Node.js Application

on:
  push:
    branches: [nodejs]
    paths:
      - 'nodejs-app/**'  # Only trigger when changes are made to the Node.js app
  workflow_dispatch:     # Allow manual trigger

env:
  S3_BUCKET: vj-test-benvolate
  ZIP_NAME: nodejs-app.zip
  ZIP_S3_KEY: artifacts/nodejs-app.zip
  EFS_PATH: /mnt/efs/code
  AWS_REGION: us-east-2
  TF_STATE_BUCKET: vj-test-benvolate
  TF_STATE_KEY: "EC2/terraform.tfstate"
  
jobs:
  deploy-nodejs:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Node.js App Repo
        uses: actions/checkout@v3
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Zip Node.js App
        run: |
          cd nodejs-app
          zip -r ../${{ env.ZIP_NAME }} .
          cd ..
          echo "Zipped application size: $(ls -lh ${{ env.ZIP_NAME }} | awk '{print $5}')"
      
      - name: Upload ZIP to S3
        run: |
          aws s3 cp ${{ env.ZIP_NAME }} s3://${{ env.S3_BUCKET }}/${{ env.ZIP_S3_KEY }}
          echo "Uploaded ${{ env.ZIP_NAME }} to s3://${{ env.S3_BUCKET }}/${{ env.ZIP_S3_KEY }}"
      
      - name: Read EC2 Instance ID from Terraform state in S3
        run: |
          aws s3 cp s3://${{ env.TF_STATE_BUCKET }}/${{ env.TF_STATE_KEY }} tfstate.json
          INSTANCE_ID=$(jq -r '.outputs.module_instance_id_for_ssm.value' tfstate.json)
          echo "Resolved EC2 Instance ID from tfstate: $INSTANCE_ID"
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          
          # Verify instance ID is set correctly
          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: INSTANCE_ID is not set. Check the Terraform state file."
            exit 1
          fi
      
      - name: Wait for EC2 and SSM to be ready
        run: |
          # First check if instance exists and is running
          echo "Checking instance status..."
          RETRY_COUNT=0
          MAX_RETRIES=5
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Check if instance exists
            if aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region "$AWS_REGION" --query "Reservations[0].Instances[0].State.Name" --output text 2>/dev/null; then
              INSTANCE_STATUS=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region "$AWS_REGION" --query "Reservations[0].Instances[0].State.Name" --output text)
              echo "Instance status: $INSTANCE_STATUS"
              
              if [ "$INSTANCE_STATUS" = "running" ]; then
                echo "Instance is running"
                break
              fi
            else
              echo "⚠️ Instance not found or error checking status. Retrying..."
            fi
            
            RETRY_COUNT=$((RETRY_COUNT+1))
            echo "Waiting for instance to be ready (Attempt $RETRY_COUNT of $MAX_RETRIES)..."
            sleep 10
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Maximum retries reached. Instance not ready."
            exit 1
          fi
          
          # Give SSM time to be fully operational
          echo "Waiting for SSM agent to be fully operational..."
          sleep 15
      
      - name: Deploy and restart app via SSM
        run: |
          # Send command via SSM to deploy and restart the app
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "# Create backup of current application",
              "TIMESTAMP=$(date +%Y%m%d%H%M%S)",
              "mkdir -p ${{ env.EFS_PATH }}/backups",
              "if [ -d \"${{ env.EFS_PATH }}/nodejs-app\" ]; then cp -r ${{ env.EFS_PATH }}/nodejs-app ${{ env.EFS_PATH }}/backups/nodejs-app-$TIMESTAMP; fi",
              
              "# Download and extract new application code",
              "aws s3 cp s3://${{ env.S3_BUCKET }}/${{ env.ZIP_S3_KEY }} /tmp/${{ env.ZIP_NAME }}",
              "mkdir -p ${{ env.EFS_PATH }}/nodejs-app",
              "unzip -o /tmp/${{ env.ZIP_NAME }} -d ${{ env.EFS_PATH }}/nodejs-app",
              "chmod -R 755 ${{ env.EFS_PATH }}/nodejs-app",
              
              "# Install dependencies",
              "cd ${{ env.EFS_PATH }}/nodejs-app",
              "npm install",
              
              "# Check for existing application process",
              "if [ -f \"${{ env.EFS_PATH }}/nodejs-app/app.pid\" ]; then",
              "  OLD_PID=$(cat ${{ env.EFS_PATH }}/nodejs-app/app.pid)",
              "  if ps -p $OLD_PID > /dev/null; then",
              "    echo \"Stopping existing application process...\"",
              "    kill $OLD_PID",
              "    sleep 2",
              "  fi",
              "fi",
              
              "# Start new application process",
              "mkdir -p ${{ env.EFS_PATH }}/logs",
              "cd ${{ env.EFS_PATH }}/nodejs-app",
              "nohup node index.js > ${{ env.EFS_PATH }}/logs/app.log 2>&1 & echo $! > app.pid",
              "echo \"New application started with PID: $(cat app.pid)\"",
              
              "# Verify the application is running",
              "sleep 5",
              "if ps -p $(cat app.pid) > /dev/null; then",
              "  echo \"Application successfully deployed and running\"",
              "else",
              "  echo \"Application failed to start\"",
              "  exit 1",
              "fi",
              
              "# View application logs",
              "tail -n 20 ${{ env.EFS_PATH }}/logs/app.log"
            ]' \
            --comment "Deploy and restart Node.js application" \
            --region ${{ env.AWS_REGION }} \
            --query "Command.CommandId" \
            --output text)
          
          echo "SSM command sent: $CMD_ID"
          
          # Wait for command to complete
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} \
              --query "Status" \
              --output text)
              
            echo "Command status: $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "Deployment successful!"
              # Print command output
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "❌ Deployment failed!"
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --output text
              exit 1
            fi
            
            echo "Waiting for deployment to complete..."
            sleep 10
          done
          
      - name: Verify application running
        run: |
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "ps aux | grep node | grep -v grep",
              "curl -s http://localhost:3000 || echo \"Unable to connect to application\"",
              "echo \"Nginx status:\"",
              "sudo systemctl status nginx | head -n 10"
            ]' \
            --comment "Verify application is running" \
            --region ${{ env.AWS_REGION }} \
            --query "Command.CommandId" \
            --output text)
            
          # Wait for verification command to complete
          for i in {1..10}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} \
              --query "Status" \
              --output text)
              
            if [ "$STATUS" = "Success" ]; then
              echo "Verification complete!"
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --output text
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "Verification failed!"
              exit 1
            fi
            
            sleep 5
          done