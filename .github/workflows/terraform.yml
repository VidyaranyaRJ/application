name: Deploy Node.js Application

on:
  push:
    branches: [nodejs]
  workflow_dispatch:

env:
  S3_BUCKET: vj-test-benvolate
  ZIP_NAME: nodejs-app.zip
  ZIP_S3_KEY: artifacts/nodejs-app.zip
  EFS_PATH: /mnt/efs/code
  AWS_REGION: us-east-2
  TF_STATE_BUCKET: vj-test-benvolate
  TF_STATE_KEY: "EC2/terraform.tfstate"

jobs:
  deploy-nodejs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Node.js App Repo
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Zip Node.js App
        run: |
          zip -r ${{ env.ZIP_NAME }} .
          echo "Zipped application size: $(ls -lh ${{ env.ZIP_NAME }} | awk '{print $5}')"

      - name: Upload ZIP to S3
        run: |
          aws s3 cp ${{ env.ZIP_NAME }} s3://${{ env.S3_BUCKET }}/${{ env.ZIP_S3_KEY }}

      - name: Read EC2 Instance ID from Terraform state in S3
        run: |
          aws s3 cp s3://${{ env.TF_STATE_BUCKET }}/${{ env.TF_STATE_KEY }} tfstate.json
          INSTANCE_ID=$(jq -r '.outputs.module_instance_id_for_ssm.value' tfstate.json)
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

      - name: Deploy and restart app via SSM (Zero Downtime)
        run: |
          # Create a deployment script that will run on the EC2 instance
          cat > deploy.sh << 'EOL'
          #!/bin/bash
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          EFS_PATH="{{ EFS_PATH }}"
          S3_BUCKET="{{ S3_BUCKET }}"
          ZIP_S3_KEY="{{ ZIP_S3_KEY }}"
          ZIP_NAME="{{ ZIP_NAME }}"
          
          # Create backup
          mkdir -p $EFS_PATH/backups
          if [ -d "$EFS_PATH/nodejs-app" ]; then 
            cp -r $EFS_PATH/nodejs-app $EFS_PATH/backups/nodejs-app-$TIMESTAMP
          fi
          
          # Download and extract the application
          mkdir -p $EFS_PATH/logs
          aws s3 cp s3://$S3_BUCKET/$ZIP_S3_KEY /tmp/$ZIP_NAME
          mkdir -p $EFS_PATH/nodejs-app-temp
          unzip -o /tmp/$ZIP_NAME -d $EFS_PATH/nodejs-app-temp
          
          # Install dependencies
          cd $EFS_PATH/nodejs-app-temp
          npm install
          
          # Start new app instance
          nohup node index.js > $EFS_PATH/logs/app-temp.log 2>&1 & 
          echo $! > app-temp.pid
          sleep 5
          
          # Check if new app started correctly
          if ps -p $(cat app-temp.pid) > /dev/null; then
            echo "New app started successfully"
          else
            echo "New app failed to start"
            cat $EFS_PATH/logs/app-temp.log
            exit 1
          fi
          
          # Update the live app
          mkdir -p $EFS_PATH/nodejs-app
          cp -r $EFS_PATH/nodejs-app-temp/* $EFS_PATH/nodejs-app/
          
          # Stop old app if running
          if [ -f "$EFS_PATH/nodejs-app/app.pid" ]; then
            kill $(cat $EFS_PATH/nodejs-app/app.pid) || echo "No existing app to stop"
          fi
          
          # Update pid file
          mv $EFS_PATH/nodejs-app-temp/app-temp.pid $EFS_PATH/nodejs-app/app.pid
          
          # Reload nginx
          sudo nginx -t && sudo systemctl reload nginx
          
          # Show logs
          echo "Recent application logs:"
          tail -n 20 $EFS_PATH/logs/app-temp.log
          EOL
          
          # Replace template variables
          sed -i "s|{{ EFS_PATH }}|${{ env.EFS_PATH }}|g" deploy.sh
          sed -i "s|{{ S3_BUCKET }}|${{ env.S3_BUCKET }}|g" deploy.sh
          sed -i "s|{{ ZIP_S3_KEY }}|${{ env.ZIP_S3_KEY }}|g" deploy.sh
          sed -i "s|{{ ZIP_NAME }}|${{ env.ZIP_NAME }}|g" deploy.sh
          
          # Upload script to S3
          aws s3 cp deploy.sh s3://${{ env.S3_BUCKET }}/scripts/deploy-nodejs.sh
          
          # Create JSON file for SSM parameters
          cat > ssm-params.json << EOF
          {
            "commands": [
              "aws s3 cp s3://${{ env.S3_BUCKET }}/scripts/deploy-nodejs.sh /tmp/deploy-nodejs.sh",
              "chmod +x /tmp/deploy-nodejs.sh",
              "/tmp/deploy-nodejs.sh"
            ]
          }
          EOF
          
          # Run deployment via SSM using the JSON parameters file
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters file://ssm-params.json \
            --comment "Zero downtime Node.js app deploy and Nginx reload" \
            --region ${{ env.AWS_REGION }} \
            --query "Command.CommandId" \
            --output text)

          echo "SSM command sent: $CMD_ID"

          # Wait for command completion and check status
          for i in {1..30}; do
            # Try to get the status (may fail if command is still processing)
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "Command status: $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment successful."
              
              # Output command result
              echo "=== Command output ==="
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --query "StandardOutputContent" \
                --output text
              break
              
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "❌ Deployment failed."
              
              # Output command result for debugging
              echo "=== Command output ==="
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --query "StandardOutputContent" \
                --output text

              echo "=== Error output ==="
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --query "StandardErrorContent" \
                --output text
                
              exit 1
            fi
            
            if [ $i -eq 30 ]; then
              echo "❌ Deployment timed out."
              exit 1
            fi
            
            sleep 5
          done